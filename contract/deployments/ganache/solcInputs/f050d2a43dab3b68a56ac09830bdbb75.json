{
  "language": "Solidity",
  "sources": {
    "contracts/MXCCollectionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./MXCCollectionV2.sol\";\n\nerror MXCCollectionFactory__NotOwner();\nerror MXCCollectionFactory__NotFound();\n\ncontract MXCCollectionFactory {\n    struct MXCCollectionData {\n        string ipfs;\n        address owner;\n        address collection;\n    }\n\n    MXCCollectionData[] public collections;\n    mapping(address => uint256[]) private userToCollections;\n\n    event newCollectionEvent(\n        address indexed collectionAddress,\n        address indexed owner\n    );\n    event editCollectionEvent(\n        address indexed collectionAddress,\n        address indexed owner\n    );\n    event delCollectionEvent(\n        address indexed collectionAddress,\n        address indexed owner\n    );\n\n    function createCollection(\n        address _marketplaceAddress,\n        string memory _name,\n        string memory _symbol,\n        uint256 _royaltiesCutPerMillion,\n        address _royaltyRecipient,\n        string memory _ipfs\n    ) external returns (address) {\n        address newCollection = address(\n            new MXCCollectionV2(\n                msg.sender,\n                _marketplaceAddress,\n                _royaltyRecipient,\n                _royaltiesCutPerMillion,\n                _name,\n                _symbol\n            )\n        );\n\n        collections.push(MXCCollectionData(_ipfs, msg.sender, newCollection));\n        uint256 index = collections.length - 1;\n        userToCollections[msg.sender].push(index);\n        emit newCollectionEvent(newCollection, msg.sender);\n        return newCollection;\n    }\n\n    function editCollection(address _collection, string memory _ipfs) external {\n        for (uint256 i = 0; i < collections.length; i++) {\n            if (collections[i].collection == _collection) {\n                if (collections[i].owner != msg.sender) {\n                    revert MXCCollectionFactory__NotOwner();\n                }\n                MXCCollectionData storage target = collections[i];\n                target.ipfs = _ipfs;\n                emit editCollectionEvent(_collection, msg.sender);\n            }\n        }\n    }\n\n    function delCollection(address _collection) external returns (address) {\n        for (uint256 i = 0; i < collections.length; i++) {\n            address collection = collections[i].collection;\n            if (collection == _collection) {\n                if (collections[i].owner != msg.sender) {\n                    revert MXCCollectionFactory__NotOwner();\n                }\n                collections[i] = collections[collections.length - 1];\n                collections.pop();\n                emit delCollectionEvent(collection, msg.sender);\n                return collection;\n            }\n        }\n        revert MXCCollectionFactory__NotFound();\n    }\n\n    function fetchCollection(\n        address _collection\n    ) public view returns (MXCCollectionData memory) {\n        for (uint256 i = 0; i < collections.length; i++) {\n            address collection = collections[i].collection;\n            if (collection == _collection) {\n                return collections[i];\n            }\n        }\n        revert MXCCollectionFactory__NotFound();\n    }\n\n    function fetchUserCollections(\n        address _user\n    ) public view returns (MXCCollectionData[] memory) {\n        uint256[] storage indices = userToCollections[_user];\n        MXCCollectionData[] memory result = new MXCCollectionData[](\n            indices.length\n        );\n        for (uint i = 0; i < indices.length; i++) {\n            result[i] = collections[indices[i]];\n        }\n        return result;\n    }\n\n    function fetchCollections()\n        public\n        view\n        returns (MXCCollectionData[] memory)\n    {\n        return collections;\n    }\n\n    function fetchCollectionsLength() public view returns (uint256) {\n        return collections.length;\n    }\n}\n"
    },
    "contracts/MXCCollectionV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721} from \"solmate/src/tokens/ERC721.sol\";\n\nerror MXCCollection__NotCreator();\nerror MXCCollection__NotExistToken();\nerror MXCCollection__NotAuthorize();\n\ncontract MXCCollectionV2 is ERC721 {\n    mapping(uint256 => string) private _tokenURIs;\n    uint256 private _tokenIdCounter;\n    uint256 public royaltiesCutPerMillion;\n    address public royaltyRecipientAddress;\n    address public marketplaceContract;\n    address public creator;\n\n    constructor(\n        address _creator,\n        address _mpAddress,\n        address _royaltyRecipient,\n        uint256 _royaltiesCutPerMillion,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        marketplaceContract = _mpAddress;\n        royaltiesCutPerMillion = _royaltiesCutPerMillion;\n        royaltyRecipientAddress = _royaltyRecipient;\n        creator = _creator;\n    }\n\n    modifier onlyCreator() {\n        if (msg.sender != creator) revert MXCCollection__NotCreator();\n        _;\n    }\n\n    function royaltyInfo(\n        uint256 _salePrice\n    ) external view returns (uint256 royaltyAmount, address royaltyRecipient) {\n        if (royaltiesCutPerMillion > 0) {\n            return (\n                (_salePrice * royaltiesCutPerMillion) / 10000,\n                royaltyRecipientAddress\n            );\n        } else {\n            return (0, address(0));\n        }\n    }\n\n    function mint(string memory _tokenURI) public onlyCreator {\n        uint256 newItemId = _tokenIdCounter;\n        _mint(msg.sender, newItemId);\n        setTokenURI(newItemId, _tokenURI);\n        setApprovalForAll(marketplaceContract, true);\n        _tokenIdCounter = _tokenIdCounter + 1;\n    }\n\n    function burn(uint256 tokenId) public {\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n            revert MXCCollection__NotAuthorize();\n        }\n        _burn(tokenId);\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            isApprovedForAll[owner][spender] ||\n            getApproved[tokenId] == spender);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory uri) public {\n        _tokenURIs[tokenId] = uri;\n    }\n\n    function exists(uint256 tokenId) internal view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        if (!exists(tokenId)) {\n            revert MXCCollection__NotExistToken();\n        }\n        return _tokenURIs[tokenId];\n    }\n}\n"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed id\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 indexed id\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from ||\n                isApprovedForAll[from][msg.sender] ||\n                msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}